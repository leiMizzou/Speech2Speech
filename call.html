<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>è¯­éŸ³é—®è¯Šï¼ˆå¸¦ä¼šè¯è®°å¿†ç¤ºä¾‹ï¼‰</title>
    <style>
        body { margin: 0; font-family: system-ui; }
        .container { max-width: 800px; margin: 0 auto; height: 100vh; display: flex; }
        
        .status-panel {
            width: 300px;
            background: #1f2937;
            color: #e5e7eb;
            padding: 1rem;
            overflow-y: auto;
            font-family: monospace;
        }
        .status-item {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-left: 3px solid;
            font-size: 14px;
        }
        .status-info { border-color: #3b82f6; }
        .status-success { border-color: #10b981; }
        .status-error { border-color: #ef4444; }
        
        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .header { 
            background: #2563eb; 
            color: white; 
            padding: 1rem; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
        }
        .doctor-info { display: flex; align-items: center; gap: 1rem; }
        .avatar { 
            width: 40px; 
            height: 40px; 
            background: #3b82f6; 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .call-status { display: flex; align-items: center; gap: 0.5rem; }
        .status-dot { 
            width: 8px; 
            height: 8px; 
            background: #4ade80; 
            border-radius: 50%; 
        }
        .chat-container { 
            flex: 1; 
            overflow-y: auto; 
            padding: 1rem; 
            background: #f9fafb; 
        }
        .message { 
            margin: 0.5rem 0; 
            max-width: 80%; 
            padding: 0.75rem; 
            border-radius: 0.5rem; 
        }
        .user-message { 
            margin-left: auto; 
            background: #2563eb; 
            color: white; 
        }
        .bot-message { 
            background: white; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
        }
        .system-message { 
            text-align: center; 
            background: #e5e7eb; 
            color: #4b5563; 
            width: 100%; 
        }
        .controls { 
            padding: 1rem; 
            background: white; 
            display: flex; 
            justify-content: center; 
            gap: 2rem; 
            border-top: 1px solid #e5e7eb; 
        }
        .btn { 
            padding: 1rem; 
            border-radius: 50%; 
            border: none; 
            cursor: pointer; 
            font-size: 1.5rem;
        }
        .btn-mute { background: #f3f4f6; color: #4b5563; }
        .btn-mute.active { background: #fee2e2; color: #ef4444; }
        .btn-call { background: #22c55e; color: white; }
        .btn-call.active { background: #ef4444; }
        .btn-interrupt { background: #f59e0b; color: white; }
        .btn-interrupt.disabled { background: #fcd34d; cursor: not-allowed; }
        .resource { 
            margin-top: 0.5rem; 
            padding: 0.5rem; 
            background: #eff6ff; 
            border-radius: 0.25rem; 
            font-size: 0.875rem; 
        }
        .timestamp { 
            font-size: 0.75rem; 
            opacity: 0.7; 
            margin-top: 0.25rem; 
        }
        @keyframes pulse { 
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .pulse { 
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; 
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- çŠ¶æ€æ—¥å¿—é¢æ¿ï¼ˆè°ƒè¯•ä¿¡æ¯ï¼‰ -->
        <div id="statusPanel" class="status-panel">
            <h3>è°ƒè¯•ä¿¡æ¯</h3>
            <div id="statusLogs"></div>
        </div>
        
        <!-- ä¸»ä½“åŒºåŸŸ -->
        <div class="main-container">
            <div class="header">
                <div class="doctor-info">
                    <div class="avatar">ç‹</div>
                    <div>
                        <h2 style="margin: 0">ç‹åŒ»ç”Ÿ</h2>
                        <p style="margin: 0; font-size: 0.875rem; opacity: 0.8">ABCåŒ»é™¢ å¿ƒç†å’¨è¯¢å¸ˆ</p>
                    </div>
                </div>
                <div class="call-status" style="display: none">
                    <div class="status-dot pulse"></div>
                    <span>é€šè¯ä¸­</span>
                </div>
            </div>
            <div id="chatContainer" class="chat-container"></div>
            <div class="controls">
                <button id="muteBtn" class="btn btn-mute" title="é™éŸ³/å–æ¶ˆé™éŸ³">ğŸ¤</button>
                <button id="callBtn" class="btn btn-call" title="å¼€å§‹/ç»“æŸé€šè¯">ğŸ“</button>
                <button id="interruptBtn" class="btn btn-interrupt disabled" title="æ‰“æ–­æ’­æ”¾" disabled>â¹ï¸</button>
            </div>
        </div>
    </div>

    <!-- éŸ³é¢‘å¤„ç†å™¨å·¥ä½œçº¿ç¨‹ä»£ç  -->
    <script type="text/worklet" id="audioWorkletScript">
        class AudioProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this.bufferSize = 2048;
                this.buffer = new Float32Array(this.bufferSize);
                this.bufferIndex = 0;
                this.sampleRate = 16000;
            }

            process(inputs, outputs, parameters) {
                const input = inputs[0][0];
                if (!input) return true;

                for (let i = 0; i < input.length; i++) {
                    this.buffer[this.bufferIndex] = input[i];
                    this.bufferIndex++;

                    if (this.bufferIndex >= this.bufferSize) {
                        const intData = new Int16Array(this.bufferSize);
                        for (let j = 0; j < this.bufferSize; j++) {
                            intData[j] = Math.max(-32768, Math.min(32767, this.buffer[j] * 32768));
                        }
                        this.port.postMessage(intData.buffer, [intData.buffer]);
                        this.bufferIndex = 0;
                        this.buffer = new Float32Array(this.bufferSize);
                    }
                }

                return true;
            }
        }

        registerProcessor('audio-processor', AudioProcessor);
    </script>

    <script>
        //================== å…¨å±€çŠ¶æ€ & å˜é‡ ==================//

        // ä¿å­˜æœ€å¤š 10 è½®çš„å¯¹è¯ï¼ˆç”¨æˆ·+AI ä¸€è½®ï¼‰ï¼Œå³æœ€å¤§ 20 æ¡æ¶ˆæ¯
        // ç»“æ„ç¤ºä¾‹ï¼š[{ role: 'user', content: '...' }, { role: 'assistant', content: '...' }, ...]
        let conversationMemory = [];

        // ç”¨æ¥è·Ÿè¸ªé€šè¯çŠ¶æ€
        let isCallActive = false;
        let isMuted = false;
        let ws = null;
        let audioStream = null;
        let audioContext = null; // ç”¨äºå½•éŸ³
        let audioWorkletNode = null;

        // ç”¨äºæ’­æ”¾ TTS çš„å…¨å±€ AudioContextï¼ˆé¿å…é¢‘ç¹åˆ›å»º/å…³é—­ï¼‰
        let globalAudioContext = null;

        // å½“å‰æ­£åœ¨æ’­æ”¾çš„ TTS æ¥æº
        let currentTTSSource = null;
        let currentTTSContext = null;

        // ç”¨äºåˆå¹¶çŸ­æš‚åœé¡¿å¯¼è‡´çš„å¤šæ¬¡ "2pass-offline" è¯†åˆ«ç»“æœ
        let pendingText = "";
        let finalTimer = null;
        const WAIT_MS = 1000; // ç­‰å¾… 1ç§’

        // DOMå…ƒç´ 
        const chatContainer = document.getElementById('chatContainer');
        const callBtn = document.getElementById('callBtn');
        const muteBtn = document.getElementById('muteBtn');
        const interruptBtn = document.getElementById('interruptBtn');
        const callStatus = document.querySelector('.call-status');
        const statusLogs = document.getElementById('statusLogs');

        //================== æ—¥å¿— & UI è¾…åŠ©å‡½æ•° ==================//

        function addStatusLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = `status-item status-${type}`;
            div.innerHTML = `[${timestamp}] ${message}`;
            statusLogs.appendChild(div);
            statusLogs.scrollTop = statusLogs.scrollHeight;
        }

        function addMessage(content, type = 'system', resources = []) {
            const div = document.createElement('div');
            div.className = `message ${type}-message`;
            div.innerHTML = `
                <div>${content}</div>
                ${resources.map(r => `
                    <div class="resource">
                        <div><strong>${r.title}</strong></div>
                        <div>${r.summary}</div>
                        <div style="font-size: 0.75rem; color: #6b7280">
                            ç›¸å…³åº¦: ${(r.rerank_score * 100).toFixed(0)}%
                        </div>
                    </div>
                `).join('')}
                <div class="timestamp">${new Date().toLocaleTimeString()}</div>
            `;
            chatContainer.appendChild(div);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        //================== ä¸AIäº¤äº’ & TTS æ’­æ”¾ ==================//

        // æ„é€ å¯¹è¯ä¸Šä¸‹æ–‡ï¼ˆåŒ…å« system æç¤º + æœ€è¿‘ 10 è½®å¯¹è¯ + å½“å‰ç”¨æˆ·é—®é¢˜ï¼‰
        function buildMessagesForAPI(userInput) {
            // 1. ç³»ç»Ÿæ¶ˆæ¯
            const systemMessage = {
                role: "system",
                content: "ä½ æ˜¯ABCåŒ»é™¢ç‹åŒ»ç”Ÿï¼Œè¯·é’ˆå¯¹æ‚£è€…æˆ–æ‚£è€…å®¶å±çš„æé—®ç»™å‡ºåˆé€‚çš„å›å¤ã€‚å›å¤è¦è¨€ç®€æ„èµ…ï¼Œæ§åˆ¶åœ¨100å­—ä»¥å†…ã€‚"
            };

            // 2. å– conversationMemory ä¸­æœ€å¤š 10 è½®çš„æ¶ˆæ¯
            // å¦‚æœå¤§äº 20 æ¡æ¶ˆæ¯ï¼Œå°±å–å 20 æ¡
            const startIndex = conversationMemory.length > 20 ? conversationMemory.length - 20 : 0;
            const trimmedMemory = conversationMemory.slice(startIndex);

            // 3. å½“å‰ç”¨æˆ·é—®é¢˜
            const userMessage = {
                role: "user",
                content: userInput
            };

            // æœ€ç»ˆ messages
            return [systemMessage, ...trimmedMemory, userMessage];
        }

        // æ›´æ–°å¯¹è¯è®°å¿†æ•°ç»„
        // å¦‚æœè¶…å‡º 10 è½®ï¼Œåˆ™ä¸¢å¼ƒæœ€æ—©çš„ä¸€è½®ï¼ˆ2 æ¡æ¶ˆæ¯ï¼‰
        function updateConversationMemory(role, content) {
            // æ¨å…¥æ–°çš„æ¶ˆæ¯
            conversationMemory.push({ role, content });

            // å¦‚æœè¶…è¿‡ 20 æ¡æ¶ˆæ¯ï¼ˆ10 è½®ï¼‰ï¼Œåˆ™ç§»é™¤æœ€æ—©çš„ 2 æ¡
            while (conversationMemory.length > 20) {
                conversationMemory.shift(); // ç§»é™¤æœ€æ—©çš„ä¸€æ¡
            }
        }

        // è·å– AI å›å¤
        async function getAIResponse(userInput) {
            addStatusLog('æ­£åœ¨è·å–AIå›å¤...', 'info');

            // å…ˆæŠŠç”¨æˆ·è¾“å…¥å­˜å…¥è®°å¿†
            // è¿™é‡Œä¸ç«‹å³ pushï¼Œå› ä¸º handleASRFinalResult ä¸­å·²ç»æ‰§è¡Œäº†ï¼šupdateConversationMemory("user", userInput)
            // å¦‚æœä½ å¸Œæœ›å…ˆæŠŠ userInput å­˜å‚¨ï¼Œç„¶åå†ç»„åˆè¯·æ±‚ï¼Œä¹Ÿå¯åœ¨ handleASRFinalResult è°ƒç”¨æ­¤å¤„æ—¶ä¿®æ”¹é€»è¾‘

            try {
                // æ„é€  messages
                const messages = buildMessagesForAPI(userInput);

                const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer sk-38ad42271d60445f93b92dfa4df3e4c5'
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: messages,
                        max_tokens: 400
                    })
                });
                const data = await response.json();
                addStatusLog('AIå›å¤æˆåŠŸ', 'success');

                // å¦‚æœ AI æ²¡æœ‰æ­£å¸¸è¿”å›ï¼Œåˆ™ç»™ä¸€ä¸ªé»˜è®¤æç¤º
                const aiText = data.choices && data.choices[0] 
                               ? data.choices[0].message.content 
                               : "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›åº”ã€‚";

                // å­˜å‚¨ AI å›å¤åˆ°å¯¹è¯è®°å¿†
                updateConversationMemory("assistant", aiText);

                return {
                    content: aiText,
                    resources: await getRecommendations(userInput)
                };
            } catch (error) {
                addStatusLog(`AIå“åº”é”™è¯¯: ${error.message}`, 'error');
                return {
                    content: "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›åº”ï¼Œè¯·ç¨åå†è¯•ã€‚",
                    resources: []
                };
            }
        }

        // è·å–ç›¸å…³èµ„æºæ¨èï¼ˆç¤ºä¾‹ï¼‰
        async function getRecommendations(text) {
            addStatusLog('æ­£åœ¨è·å–æ¨èèµ„æº...', 'info');
            const triggers = ['æŠ‘éƒ', 'ç„¦è™‘', 'ç¡çœ ', 'å‹åŠ›'];
            if (triggers.some(trigger => text.includes(trigger))) {
                addStatusLog('æ‰¾åˆ°ç›¸å…³æ¨èèµ„æº', 'success');
                return [{
                    title: "å¿ƒç†å¥åº·è‡ªåŠ©æŒ‡å—",
                    summary: "æä¾›å®ç”¨çš„å¿ƒç†å¥åº·ç®¡ç†å»ºè®®å’ŒæŠ€å·§",
                    rerank_score: 0.85
                }];
            }
            addStatusLog('æœªæ‰¾åˆ°ç›¸å…³æ¨èèµ„æº', 'info');
            return [];
        }

        // æ’­æ”¾ TTS è¯­éŸ³
        async function playTTS(text) {
            addStatusLog('æ­£åœ¨è½¬æ¢è¯­éŸ³...', 'info');
            try {
                // ä¿å­˜éº¦å…‹é£çš„å½“å‰çŠ¶æ€
                const wasMutedBefore = isMuted;
                if (!wasMutedBefore && audioStream) {
                    isMuted = true;
                    audioStream.getAudioTracks().forEach(track => {
                        track.enabled = false;
                    });
                    muteBtn.classList.add('active');
                    muteBtn.textContent = 'ğŸ”‡';
                    addStatusLog('æ’­æ”¾è¯­éŸ³æ—¶è‡ªåŠ¨é™éŸ³éº¦å…‹é£', 'info');
                }

                // å¦‚æœå…¨å±€ AudioContext å°šæœªåˆ›å»ºï¼Œåˆ™åˆ›å»º
                if (!globalAudioContext) {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                }

                // è¯·æ±‚ TTS éŸ³é¢‘ï¼ˆè¯·è‡ªè¡Œä¿®æ”¹ TTS æœåŠ¡åœ°å€ï¼‰
                const encodedText = encodeURIComponent(text);
                const ttsUrl = `http://192.168.8.16:9880/?text=${encodedText}&text_language=zh`;

                const response = await fetch(ttsUrl, { method: 'GET' });
                if (!response.ok) {
                    throw new Error(`TTS è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
                }

                const audioData = await response.arrayBuffer();
                const audioBuffer = await globalAudioContext.decodeAudioData(audioData);
                const source = globalAudioContext.createBufferSource();
                source.buffer = audioBuffer;

                // åˆ›å»ºå¢ç›ŠèŠ‚ç‚¹ä»¥æ”¯æŒæ·¡å‡º
                const gainNode = globalAudioContext.createGain();
                gainNode.gain.setValueAtTime(1, globalAudioContext.currentTime);
                source.connect(gainNode).connect(globalAudioContext.destination);

                // ç›‘å¬æ’­æ”¾ç»“æŸäº‹ä»¶
                source.onended = () => {
                    addStatusLog('è¯­éŸ³æ’­æ”¾ç»“æŸ', 'info');
                    // æ¢å¤éº¦å…‹é£çŠ¶æ€
                    if (!wasMutedBefore && audioStream) {
                        isMuted = false;
                        audioStream.getAudioTracks().forEach(track => {
                            track.enabled = true;
                        });
                        muteBtn.classList.remove('active');
                        muteBtn.textContent = 'ğŸ¤';
                        addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                    }
                    // æ¸…é™¤ TTS æ’­æ”¾çŠ¶æ€
                    currentTTSSource = null;
                    currentTTSContext = null;
                    // ç¦ç”¨æ‰“æ–­æŒ‰é’®
                    interruptBtn.disabled = true;
                    interruptBtn.classList.add('disabled');
                };

                // å¼€å§‹æ’­æ”¾
                source.start(0);
                addStatusLog('è¯­éŸ³æ’­æ”¾æˆåŠŸ', 'success');

                // è®°å½• TTS æ’­æ”¾çŠ¶æ€
                currentTTSSource = source;
                currentTTSContext = globalAudioContext;

                // å¯ç”¨æ‰“æ–­æŒ‰é’®
                interruptBtn.disabled = false;
                interruptBtn.classList.remove('disabled');

            } catch (error) {
                addStatusLog(`TTSæ’­æ”¾é”™è¯¯: ${error.message}`, 'error');
                // å¦‚æœåœ¨æ’­æ”¾è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œç¡®ä¿æ¢å¤éº¦å…‹é£çŠ¶æ€
                if (isMuted && !muteBtn.classList.contains('active') && audioStream) {
                    isMuted = false;
                    audioStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                    muteBtn.classList.remove('active');
                    muteBtn.textContent = 'ğŸ¤';
                    addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                }
            }
        }

        //================== ä¼˜åŒ–åçš„ä¸­æ–­ TTS å‡½æ•° ==================//
        async function interruptTTS() {
            if (currentTTSSource && currentTTSContext) {
                addStatusLog('æ­£åœ¨ä¸­æ–­ TTS æ’­æ”¾...', 'info');

                try {
                    // æ–­å¼€éŸ³æº
                    currentTTSSource.disconnect();
                    addStatusLog('éŸ³é¢‘æºå·²æ–­å¼€è¿æ¥', 'info');

                    // åˆ›å»ºä¸€ä¸ªå¢ç›ŠèŠ‚ç‚¹æ‰§è¡Œå¿«é€Ÿæ·¡å‡º
                    const gainNode = currentTTSContext.createGain();
                    currentTTSSource.connect(gainNode).connect(currentTTSContext.destination);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, currentTTSContext.currentTime);
                    // 50msæ·¡å‡º
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, currentTTSContext.currentTime + 0.05);

                    // 50msååœæ­¢éŸ³æºï¼Œå†å»¶è¿Ÿæ¢å¤éº¦å…‹é£
                    setTimeout(() => {
                        try {
                            currentTTSSource.stop(0);
                            addStatusLog('éŸ³é¢‘æºå·²åœæ­¢æ’­æ”¾', 'info');
                        } catch (err) {
                            addStatusLog(`åœæ­¢éŸ³æºæ—¶å‘ç”Ÿé”™è¯¯: ${err.message}`, 'error');
                        }

                        // ä¸å…³é—­ globalAudioContext

                        // æ¸…ç†å¼•ç”¨
                        currentTTSSource = null;
                        currentTTSContext = null;

                        // å†åŠ ä¸€ç‚¹å»¶è¿Ÿæ¢å¤éº¦å…‹é£
                        setTimeout(() => {
                            if (isMuted && audioStream) {
                                isMuted = false;
                                audioStream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });
                                muteBtn.classList.remove('active');
                                muteBtn.textContent = 'ğŸ¤';
                                addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                            }

                            // æ›´æ–° UI
                            interruptBtn.disabled = true;
                            interruptBtn.classList.add('disabled');
                            addMessage('è¯­éŸ³æ’­æ”¾å·²ä¸­æ–­ï¼Œæ‚¨å¯ä»¥ç»§ç»­å’¨è¯¢', 'system');
                        }, 100);
                    }, 50);
                } catch (error) {
                    addStatusLog(`ä¸­æ–­ TTS æ’­æ”¾å¤±è´¥: ${error.message}`, 'error');
                }
            } else {
                // å½“å‰æ²¡æœ‰TTSåœ¨æ’­æ”¾ï¼Œä¹Ÿè¦ç¡®ä¿éº¦å…‹é£æ¢å¤
                if (isMuted && audioStream) {
                    isMuted = false;
                    audioStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                    muteBtn.classList.remove('active');
                    muteBtn.textContent = 'ğŸ¤';
                    addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                }
                interruptBtn.disabled = true;
                interruptBtn.classList.add('disabled');
                addMessage('å½“å‰æ²¡æœ‰æ­£åœ¨æ’­æ”¾çš„è¯­éŸ³', 'system');
            }
        }

        //================== WebSocket & è¯†åˆ«ç»“æœå¤„ç† ==================//

        // æŠŠä¸€æ¬¡å®Œæ•´çš„è¯è¯­åˆå¹¶åå‘é€ç»™AIå¹¶æ’­æ”¾TTS
        async function handleASRFinalResult(text) {
            // å°†ç”¨æˆ·è¯´çš„è¯å­˜å…¥ conversationMemory
            // ï¼ˆæ³¨æ„ï¼šå¦‚æœæ‚¨æƒ³åœ¨ AI å›å¤åå†ç»Ÿä¸€ç®¡ç†ï¼Œä¹Ÿå¯æ ¹æ®éœ€æ±‚è‡ªè¡Œè°ƒæ•´é€»è¾‘ï¼‰
            updateConversationMemory("user", text);

            // å…ˆåˆå¹¶åˆ° pendingText
            pendingText = pendingText ? (pendingText + " " + text) : text;
            addStatusLog(`è¯†åˆ«åˆ°æœ€ç»ˆæ–‡æœ¬: ${text}`, 'info');

            // å¦‚æœæœ‰å°šæœªè§¦å‘çš„å®šæ—¶å™¨ï¼Œå…ˆæ¸…é™¤
            if (finalTimer) {
                clearTimeout(finalTimer);
                finalTimer = null;
            }

            // é‡è®¾ä¸€ä¸ªå®šæ—¶å™¨ï¼Œ1ç§’åè§¦å‘
            finalTimer = setTimeout(async () => {
                // è®¤ä¸ºç”¨æˆ·è¯´è¯ç»“æŸ
                const userInput = pendingText.trim();
                addMessage(userInput, 'user'); // åœ¨é¡µé¢ä¸­æ˜¾ç¤ºç”¨æˆ·æ–‡æœ¬

                // è¯·æ±‚AIå¹¶æ’­æ”¾TTS
                const aiResponse = await getAIResponse(userInput);
                await playTTS(aiResponse.content);
                addMessage(aiResponse.content, 'bot', aiResponse.resources);

                // æ¸…ç©ºåˆå¹¶ç¼“å†²
                pendingText = "";
                finalTimer = null;
            }, WAIT_MS);
        }

        //================== é€šè¯æ§åˆ¶é€»è¾‘ ==================//

        async function startCall() {
            try {
                addStatusLog('æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...', 'info');
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000
                    } 
                });
                addStatusLog('éº¦å…‹é£æƒé™è·å–æˆåŠŸ', 'success');

                // åˆ›å»ºå½•éŸ³ç”¨ AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                // åŠ è½½ AudioWorklet
                const audioWorkletSource = document.getElementById('audioWorkletScript').textContent;
                const workletBlob = new Blob([audioWorkletSource], { type: 'text/javascript' });
                const workletUrl = URL.createObjectURL(workletBlob);
                await audioContext.audioWorklet.addModule(workletUrl);

                // å»ºç«‹ WebSocket è¿æ¥
                const wsUrl = 'wss://192.168.8.167:10096';
                ws = new WebSocket(wsUrl);

                ws.onopen = async () => {
                    addStatusLog('WebSocketè¿æ¥æˆåŠŸ', 'success');
                    // å‘é€ ASR é…ç½®
                    const config = {
                        mode: "2pass",
                        chunk_size: [5, 10, 5],
                        chunk_interval: 10,
                        wav_name: "microphone",
                        is_speaking: true,
                        hotwords: "",
                        itn: true
                    };
                    ws.send(JSON.stringify(config));
                    addStatusLog('å·²å‘é€ASRé…ç½®ä¿¡æ¯', 'info');

                    // è¿æ¥åˆ°AudioWorklet
                    const source = audioContext.createMediaStreamSource(audioStream);
                    audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');
                    audioWorkletNode.port.onmessage = (event) => {
                        if (isCallActive && !isMuted && ws.readyState === WebSocket.OPEN) {
                            ws.send(event.data);
                        }
                    };
                    source.connect(audioWorkletNode);

                    addStatusLog('å¼€å§‹å½•éŸ³', 'success');
                };

                ws.onerror = (error) => {
                    addStatusLog(`WebSocketé”™è¯¯: ${error}`, 'error');
                };

                ws.onclose = () => {
                    addStatusLog('WebSocketè¿æ¥å·²å…³é—­', 'info');
                    endCall();
                };

                ws.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.text && data.mode === "2pass-offline") {
                            handleASRFinalResult(data.text);
                        }
                    } catch (error) {
                        addStatusLog(`å¤„ç†æ¶ˆæ¯é”™è¯¯: ${error.message}`, 'error');
                    }
                };

                isCallActive = true;
                callBtn.classList.add('active');
                callStatus.style.display = 'flex';
                addMessage('é€šè¯å·²å¼€å§‹ï¼Œæ‚¨å¯ä»¥å¼€å§‹å’¨è¯¢');
            } catch (error) {
                addStatusLog(`å¯åŠ¨é€šè¯é”™è¯¯: ${error.message}`, 'error');
                addMessage('å¯åŠ¨é€šè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™');
            }
        }

        async function endCall() {
            if (!isCallActive) {
                return;
            }
            addStatusLog('æ­£åœ¨ç»“æŸé€šè¯...', 'info');
            isCallActive = false;

            // å…³é—­ WebSocket
            if (ws) {
                ws.close();
                addStatusLog('WebSocketå·²å…³é—­', 'info');
                ws = null;
            }
            
            // æ–­å¼€éŸ³é¢‘å¤„ç†å™¨
            if (audioWorkletNode) {
                audioWorkletNode.disconnect();
                addStatusLog('éŸ³é¢‘å¤„ç†å™¨å·²æ–­å¼€', 'info');
                audioWorkletNode = null;
            }
            
            // å…³é—­å½•éŸ³çš„ AudioContext
            if (audioContext) {
                try {
                    if (audioContext.state !== 'closed') {
                        await audioContext.close();
                        addStatusLog('æ•è·ç”¨AudioContextå·²å…³é—­', 'info');
                    }
                } catch (error) {
                    addStatusLog(`å…³é—­AudioContextå¤±è´¥: ${error.message}`, 'error');
                }
                audioContext = null;
            }
            
            // åœæ­¢éŸ³é¢‘æµ
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                addStatusLog('éŸ³é¢‘æµå·²å…³é—­', 'info');
                audioStream = null;
            }

            // å¦‚æœæœ‰å°šæœªå¤„ç†çš„åˆå¹¶æ–‡æœ¬ï¼Œç›´æ¥æ¸…ç©º
            if (pendingText) {
                pendingText = "";
            }
            if (finalTimer) {
                clearTimeout(finalTimer);
                finalTimer = null;
            }

            // å¦‚æœæœ‰ TTS æ­£åœ¨æ’­æ”¾ï¼Œå¼ºåˆ¶ä¸­æ–­
            if (currentTTSSource) {
                interruptTTS();
            }

            // æ›´æ–° UI
            callBtn.classList.remove('active');
            callStatus.style.display = 'none';
            addMessage('é€šè¯å·²ç»“æŸ');
            addStatusLog('é€šè¯ç»“æŸå®Œæˆ', 'success');
        }

        //================== æŒ‰é’®äº‹ä»¶ç»‘å®š ==================//

        callBtn.onclick = () => {
            if (!isCallActive) {
                startCall();
            } else {
                endCall();
            }
        };

        muteBtn.onclick = () => {
            if (audioStream) {
                isMuted = !isMuted;
                audioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMuted;
                });
                muteBtn.classList.toggle('active', isMuted);
                muteBtn.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ¤';
                addStatusLog(`éº¦å…‹é£å·²${isMuted ? 'é™éŸ³' : 'å–æ¶ˆé™éŸ³'}`, 'info');
            }
        };

        interruptBtn.onclick = () => {
            if (!interruptBtn.disabled) {
                interruptTTS();
            }
        };

        //================== é¡µé¢åŠ è½½/å¸è½½å¤„ç† ==================//

        window.onload = async () => {
            addStatusLog('é¡µé¢åˆå§‹åŒ–å¼€å§‹', 'info');
            
            // ç®€è¦åŠŸèƒ½æ£€æŸ¥
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘è¾“å…¥ (getUserMedia)', 'error');
                return;
            }
            if (!window.WebSocket) {
                addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebSocket', 'error');
                return;
            }
            if (!window.AudioContext && !window.webkitAudioContext) {
                addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWeb Audio API', 'error');
                return;
            }

            // å¿«é€Ÿæ£€æŸ¥ AudioWorklet
            let tempContext;
            try {
                tempContext = new (window.AudioContext || window.webkitAudioContext)();
                if (!tempContext.audioWorklet) {
                    addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒAudioWorklet', 'error');
                    tempContext.close();
                    return;
                }
                tempContext.close();
            } catch (err) {
                addStatusLog(`éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–å¤±è´¥: ${err.message}`, 'error');
                return;
            }
            
            addStatusLog('æµè§ˆå™¨åŠŸèƒ½æ£€æŸ¥å®Œæˆ', 'success');
            addStatusLog('é¡µé¢åˆå§‹åŒ–å®Œæˆ', 'success');
            addMessage('ç³»ç»Ÿå°±ç»ªï¼Œç‚¹å‡»é€šè¯æŒ‰é’®å¼€å§‹å’¨è¯¢');
        };

        window.onbeforeunload = () => {
            if (isCallActive) {
                endCall();
            }
        };
    </script>
</body>
</html>
