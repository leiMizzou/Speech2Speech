<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>è¯­éŸ³é—®è¯Šï¼ˆè‡ªåŠ¨æ»šåŠ¨ & 10è½®ä¼šè¯è®°å¿†ï¼‰</title>
    <style>
        body { margin: 0; font-family: system-ui; }
        .container { max-width: 800px; margin: 0 auto; height: 100vh; display: flex; }
        
        /* å·¦ä¾§è°ƒè¯•ä¿¡æ¯é¢æ¿ */
        .status-panel {
            width: 300px;
            background: #1f2937;
            color: #e5e7eb;
            padding: 1rem;
            overflow-y: auto; /* å…è®¸å‚ç›´æ»šåŠ¨ */
            font-family: monospace;
            display: flex;
            flex-direction: column; /* æ­£å¸¸ä»ä¸Šåˆ°ä¸‹æ’å…¥æ—¥å¿— */
        }
        .status-item {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-left: 3px solid;
            font-size: 14px;
        }
        .status-info { border-color: #3b82f6; }
        .status-success { border-color: #10b981; }
        .status-error { border-color: #ef4444; }
        
        /* å³ä¾§ä¸»å†…å®¹åŒº */
        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .header { 
            background: #2563eb; 
            color: white; 
            padding: 1rem; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
        }
        .doctor-info { display: flex; align-items: center; gap: 1rem; }
        .avatar { 
            width: 40px; 
            height: 40px; 
            background: #3b82f6; 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .call-status { display: flex; align-items: center; gap: 0.5rem; }
        .status-dot { 
            width: 8px; 
            height: 8px; 
            background: #4ade80; 
            border-radius: 50%; 
        }
        .chat-container { 
            flex: 1; 
            overflow-y: auto; 
            padding: 1rem; 
            background: #f9fafb; 
        }
        .message { 
            margin: 0.5rem 0; 
            max-width: 80%; 
            padding: 0.75rem; 
            border-radius: 0.5rem; 
        }
        .user-message { 
            margin-left: auto; 
            background: #2563eb; 
            color: white; 
        }
        .bot-message { 
            background: white; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
        }
        .system-message { 
            text-align: center; 
            background: #e5e7eb; 
            color: #4b5563; 
            width: 100%; 
        }
        .controls { 
            padding: 1rem; 
            background: white; 
            display: flex; 
            justify-content: center; 
            gap: 2rem; 
            border-top: 1px solid #e5e7eb; 
        }
        .btn { 
            padding: 1rem; 
            border-radius: 50%; 
            border: none; 
            cursor: pointer; 
            font-size: 1.5rem;
        }
        .btn-mute { background: #f3f4f6; color: #4b5563; }
        .btn-mute.active { background: #fee2e2; color: #ef4444; }
        .btn-call { background: #22c55e; color: white; }
        .btn-call.active { background: #ef4444; }
        .btn-interrupt { background: #f59e0b; color: white; }
        .btn-interrupt.disabled { background: #fcd34d; cursor: not-allowed; }
        .resource { 
            margin-top: 0.5rem; 
            padding: 0.5rem; 
            background: #eff6ff; 
            border-radius: 0.25rem; 
            font-size: 0.875rem; 
        }
        .timestamp { 
            font-size: 0.75rem; 
            opacity: 0.7; 
            margin-top: 0.25rem; 
        }
        @keyframes pulse { 
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .pulse { 
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; 
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§é¢æ¿ï¼šæ˜¾ç¤ºè°ƒè¯•æ—¥å¿— -->
        <div id="statusPanel" class="status-panel">
            <h3>è°ƒè¯•ä¿¡æ¯</h3>
            <div id="statusLogs"></div>
        </div>
        
        <!-- å³ä¾§ä¸»å†…å®¹åŒºï¼šèŠå¤©ç•Œé¢ã€æ§åˆ¶æŒ‰é’®ç­‰ -->
        <div class="main-container">
            <div class="header">
                <div class="doctor-info">
                    <div class="avatar">ç‹</div>
                    <div>
                        <h2 style="margin: 0">ç‹åŒ»ç”Ÿ</h2>
                        <p style="margin: 0; font-size: 0.875rem; opacity: 0.8">ABCåŒ»é™¢ å¿ƒç†å’¨è¯¢å¸ˆ</p>
                    </div>
                </div>
                <div class="call-status" style="display: none">
                    <div class="status-dot pulse"></div>
                    <span>é€šè¯ä¸­</span>
                </div>
            </div>
            <div id="chatContainer" class="chat-container"></div>
            <div class="controls">
                <button id="muteBtn" class="btn btn-mute" title="é™éŸ³/å–æ¶ˆé™éŸ³">ğŸ¤</button>
                <button id="callBtn" class="btn btn-call" title="å¼€å§‹/ç»“æŸé€šè¯">ğŸ“</button>
                <button id="interruptBtn" class="btn btn-interrupt disabled" title="æ‰“æ–­æ’­æ”¾" disabled>â¹ï¸</button>
            </div>
        </div>
    </div>

    <!-- éŸ³é¢‘å¤„ç†å™¨å·¥ä½œçº¿ç¨‹ä»£ç ï¼šAudioWorklet -->
    <script type="text/worklet" id="audioWorkletScript">
        class AudioProcessor extends AudioWorkletProcessor {
            constructor() {
                super();
                this.bufferSize = 2048;
                this.buffer = new Float32Array(this.bufferSize);
                this.bufferIndex = 0;
                this.sampleRate = 16000;
            }

            process(inputs, outputs, parameters) {
                const input = inputs[0][0];
                if (!input) return true;

                for (let i = 0; i < input.length; i++) {
                    this.buffer[this.bufferIndex] = input[i];
                    this.bufferIndex++;

                    if (this.bufferIndex >= this.bufferSize) {
                        const intData = new Int16Array(this.bufferSize);
                        for (let j = 0; j < this.bufferSize; j++) {
                            intData[j] = Math.max(-32768, Math.min(32767, this.buffer[j] * 32768));
                        }
                        this.port.postMessage(intData.buffer, [intData.buffer]);
                        this.bufferIndex = 0;
                        this.buffer = new Float32Array(this.bufferSize);
                    }
                }

                return true;
            }
        }

        registerProcessor('audio-processor', AudioProcessor);
    </script>

    <script>
        //================== 1. å…¨å±€çŠ¶æ€ & å˜é‡ ==================//

        // ä¿å­˜æœ€å¤š 10 è½®å¯¹è¯ï¼ˆç”¨æˆ·+AIï¼‰ï¼Œå³æœ€å¤š 20 æ¡æ¶ˆæ¯
        let conversationMemory = [];

        let isCallActive = false;  // æ˜¯å¦æ­£åœ¨é€šè¯
        let isMuted = false;       // æ˜¯å¦é™éŸ³
        let ws = null;            // WebSocket
        let audioStream = null;   // éº¦å…‹é£æµ
        let audioContext = null;  // ç”¨äºå½•éŸ³çš„ AudioContext
        let audioWorkletNode = null;

        // ç”¨äºæ’­æ”¾ TTS çš„å…¨å±€ AudioContextï¼ˆé¿å…é¢‘ç¹åˆ›å»ºæˆ–å…³é—­ï¼‰
        let globalAudioContext = null;
        let currentTTSSource = null;   // å½“å‰ TTS éŸ³é¢‘æº
        let currentTTSContext = null;  // å½“å‰ TTS æ’­æ”¾ä½¿ç”¨çš„ AudioContext

        // çŸ­æš‚åœé¡¿åˆå¹¶
        let pendingText = "";
        let finalTimer = null;
        const WAIT_MS = 1000; // 1 ç§’

        // è·å–é¡µé¢å…ƒç´ 
        const chatContainer = document.getElementById('chatContainer');
        const callBtn = document.getElementById('callBtn');
        const muteBtn = document.getElementById('muteBtn');
        const interruptBtn = document.getElementById('interruptBtn');
        const callStatus = document.querySelector('.call-status');
        const statusLogs = document.getElementById('statusLogs');
        const statusPanel = document.getElementById('statusPanel');

        //================== 2. æ—¥å¿— & UI è¾…åŠ©å‡½æ•° ==================//

        // åœ¨å·¦ä¾§è°ƒè¯•ä¿¡æ¯é¢æ¿æ·»åŠ æ—¥å¿—ï¼Œå¹¶è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        function addStatusLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = `status-item status-${type}`;
            div.innerHTML = `[${timestamp}] ${message}`;
            statusLogs.appendChild(div);

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            statusPanel.scrollTop = statusPanel.scrollHeight;
        }

        // å‘èŠå¤©çª—å£ä¸­æ·»åŠ ä¸€æ¡æ¶ˆæ¯
        function addMessage(content, type = 'system', resources = []) {
            const div = document.createElement('div');
            div.className = `message ${type}-message`;
            div.innerHTML = `
                <div>${content}</div>
                ${resources.map(r => `
                    <div class="resource">
                        <div><strong>${r.title}</strong></div>
                        <div>${r.summary}</div>
                        <div style="font-size: 0.75rem; color: #6b7280">
                            ç›¸å…³åº¦: ${(r.rerank_score * 100).toFixed(0)}%
                        </div>
                    </div>
                `).join('')}
                <div class="timestamp">${new Date().toLocaleTimeString()}</div>
            `;
            chatContainer.appendChild(div);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        //================== 3. ä¼šè¯è®°å¿†ç®¡ç†å‡½æ•° ==================//

        // å°†æœ€æ–°çš„ä¸€æ¡å¯¹è¯(ç”¨æˆ·/AI)å­˜å…¥ä¼šè¯è®°å¿†
        // å¦‚æœé•¿åº¦è¶…è¿‡ 20 æ¡ï¼Œåˆ™ä¸¢å¼ƒæœ€æ—©çš„
        function updateConversationMemory(role, content) {
            conversationMemory.push({ role, content });
            while (conversationMemory.length > 20) {
                conversationMemory.shift(); // ç§»é™¤æœ€æ—©çš„ 2 æ¡
            }
        }

        // æ„é€ è¯·æ±‚ AI æ—¶çš„ messages æ•°ç»„ï¼šç³»ç»Ÿæç¤º + æœ€è¿‘10è½® + å½“å‰ç”¨æˆ·è¾“å…¥
        function buildMessagesForAPI(userInput) {
            // 1. system æç¤º
            const systemMessage = {
                role: "system",
                content: "ä½ æ˜¯ABCåŒ»é™¢ç‹åŒ»ç”Ÿï¼Œè¯·é’ˆå¯¹æ‚£è€…æˆ–æ‚£è€…å®¶å±çš„æé—®ç»™å‡ºåˆé€‚çš„å›å¤ã€‚å›å¤è¦è¨€ç®€æ„èµ…ï¼Œæ§åˆ¶åœ¨100å­—ä»¥å†…ã€‚"
            };

            // 2. å–æœ€è¿‘ 20 æ¡
            const startIndex = conversationMemory.length > 20 ? conversationMemory.length - 20 : 0;
            const trimmedMemory = conversationMemory.slice(startIndex);

            // 3. å½“å‰ç”¨æˆ·æ¶ˆæ¯
            const userMessage = { role: 'user', content: userInput };

            // ç»„åˆ
            return [systemMessage, ...trimmedMemory, userMessage];
        }

        //================== 4. ä¸AIäº¤äº’ & TTS æ’­æ”¾ ==================//

        // è·å–æ¨èèµ„æºç¤ºä¾‹
        async function getRecommendations(text) {
            addStatusLog('æ­£åœ¨è·å–æ¨èèµ„æº...', 'info');
            const triggers = ['æŠ‘éƒ', 'ç„¦è™‘', 'ç¡çœ ', 'å‹åŠ›'];
            if (triggers.some(trigger => text.includes(trigger))) {
                addStatusLog('æ‰¾åˆ°ç›¸å…³æ¨èèµ„æº', 'success');
                return [{
                    title: "å¿ƒç†å¥åº·è‡ªåŠ©æŒ‡å—",
                    summary: "æä¾›å®ç”¨çš„å¿ƒç†å¥åº·ç®¡ç†å»ºè®®å’ŒæŠ€å·§",
                    rerank_score: 0.85
                }];
            }
            addStatusLog('æœªæ‰¾åˆ°ç›¸å…³æ¨èèµ„æº', 'info');
            return [];
        }

        // è·å– AI å›å¤
        async function getAIResponse(userInput) {
            addStatusLog('æ­£åœ¨è·å–AIå›å¤...', 'info');

            // æ„é€ æ¶ˆæ¯ä¸Šä¸‹æ–‡
            const messages = buildMessagesForAPI(userInput);

            try {
                const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer sk-38ad42271d60445f93b92dfa4df3e4c5'
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: messages,
                        max_tokens: 400
                    })
                });
                const data = await response.json();
                addStatusLog('AIå›å¤æˆåŠŸ', 'success');

                const aiText = (data.choices && data.choices[0])
                    ? data.choices[0].message.content
                    : "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›åº”ã€‚";

                // å°†AIçš„å›å¤å­˜å…¥å¯¹è¯è®°å¿†
                updateConversationMemory("assistant", aiText);

                return {
                    content: aiText,
                    resources: await getRecommendations(userInput)
                };
            } catch (error) {
                addStatusLog(`AIå“åº”é”™è¯¯: ${error.message}`, 'error');
                return {
                    content: "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›åº”ï¼Œè¯·ç¨åå†è¯•ã€‚",
                    resources: []
                };
            }
        }

        // æ’­æ”¾ TTS è¯­éŸ³
        async function playTTS(text) {
            addStatusLog('æ­£åœ¨è½¬æ¢è¯­éŸ³...', 'info');
            try {
                const wasMutedBefore = isMuted;
                if (!wasMutedBefore && audioStream) {
                    isMuted = true;
                    audioStream.getAudioTracks().forEach(track => {
                        track.enabled = false;
                    });
                    muteBtn.classList.add('active');
                    muteBtn.textContent = 'ğŸ”‡';
                    addStatusLog('æ’­æ”¾è¯­éŸ³æ—¶è‡ªåŠ¨é™éŸ³éº¦å…‹é£', 'info');
                }

                // å¦‚æœè¿˜æ²¡æœ‰å…¨å±€ AudioContextï¼Œå°±åˆ›å»ºä¸€ä¸ª
                if (!globalAudioContext) {
                    globalAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                }

                // å‘ TTS æœåŠ¡è¯·æ±‚éŸ³é¢‘
                const encodedText = encodeURIComponent(text);
                // è¯·æ ¹æ®å®é™…æœåŠ¡å™¨åœ°å€è¿›è¡Œä¿®æ”¹
                const ttsUrl = `http://192.168.8.16:9880/?text=${encodedText}&text_language=zh`;

                const response = await fetch(ttsUrl, { method: 'GET' });
                if (!response.ok) {
                    throw new Error(`TTS è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
                }

                const audioData = await response.arrayBuffer();
                const audioBuffer = await globalAudioContext.decodeAudioData(audioData);
                const source = globalAudioContext.createBufferSource();
                source.buffer = audioBuffer;

                // åˆ›å»ºå¢ç›ŠèŠ‚ç‚¹ä»¥å®ç°æ·¡å‡º
                const gainNode = globalAudioContext.createGain();
                gainNode.gain.setValueAtTime(1, globalAudioContext.currentTime);
                source.connect(gainNode).connect(globalAudioContext.destination);

                // ç›‘å¬æ’­æ”¾ç»“æŸ
                source.onended = () => {
                    addStatusLog('è¯­éŸ³æ’­æ”¾ç»“æŸ', 'info');
                    // æ¢å¤éº¦å…‹é£
                    if (!wasMutedBefore && audioStream) {
                        isMuted = false;
                        audioStream.getAudioTracks().forEach(track => {
                            track.enabled = true;
                        });
                        muteBtn.classList.remove('active');
                        muteBtn.textContent = 'ğŸ¤';
                        addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                    }

                    currentTTSSource = null;
                    currentTTSContext = null;
                    // ç¦ç”¨æ‰“æ–­æŒ‰é’®
                    interruptBtn.disabled = true;
                    interruptBtn.classList.add('disabled');
                };

                // å¼€å§‹æ’­æ”¾
                source.start(0);
                addStatusLog('è¯­éŸ³æ’­æ”¾æˆåŠŸ', 'success');

                // è®°å½• TTS æ’­æ”¾çŠ¶æ€
                currentTTSSource = source;
                currentTTSContext = globalAudioContext;

                // å¯ç”¨â€œæ‰“æ–­â€æŒ‰é’®
                interruptBtn.disabled = false;
                interruptBtn.classList.remove('disabled');

            } catch (error) {
                addStatusLog(`TTSæ’­æ”¾é”™è¯¯: ${error.message}`, 'error');
                // å¦‚æœå‘ç”Ÿé”™è¯¯ï¼Œä¹Ÿè¦ç¡®ä¿éº¦å…‹é£æ¢å¤
                if (isMuted && !muteBtn.classList.contains('active') && audioStream) {
                    isMuted = false;
                    audioStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                    muteBtn.classList.remove('active');
                    muteBtn.textContent = 'ğŸ¤';
                    addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                }
            }
        }

        //================== 5. æ‰“æ–­ TTS æ’­æ”¾å‡½æ•° ==================//

        async function interruptTTS() {
            if (currentTTSSource && currentTTSContext) {
                addStatusLog('æ­£åœ¨ä¸­æ–­ TTS æ’­æ”¾...', 'info');

                try {
                    currentTTSSource.disconnect();
                    addStatusLog('éŸ³é¢‘æºå·²æ–­å¼€è¿æ¥', 'info');

                    // å¿«é€Ÿæ·¡å‡º
                    const gainNode = currentTTSContext.createGain();
                    currentTTSSource.connect(gainNode).connect(currentTTSContext.destination);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, currentTTSContext.currentTime);
                    // 50msæ·¡å‡º
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, currentTTSContext.currentTime + 0.05);

                    setTimeout(() => {
                        try {
                            currentTTSSource.stop(0);
                            addStatusLog('éŸ³é¢‘æºå·²åœæ­¢æ’­æ”¾', 'info');
                        } catch (err) {
                            addStatusLog(`åœæ­¢éŸ³æºæ—¶å‘ç”Ÿé”™è¯¯: ${err.message}`, 'error');
                        }

                        // ä¸å…³é—­ globalAudioContextï¼Œä¾›ä¸‹æ¬¡ TTS ä½¿ç”¨
                        currentTTSSource = null;
                        currentTTSContext = null;

                        // ç­‰ 100ms å†æ¢å¤éº¦å…‹é£
                        setTimeout(() => {
                            if (isMuted && audioStream) {
                                isMuted = false;
                                audioStream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });
                                muteBtn.classList.remove('active');
                                muteBtn.textContent = 'ğŸ¤';
                                addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                            }
                            interruptBtn.disabled = true;
                            interruptBtn.classList.add('disabled');
                            addMessage('è¯­éŸ³æ’­æ”¾å·²ä¸­æ–­ï¼Œæ‚¨å¯ä»¥ç»§ç»­å’¨è¯¢', 'system');
                        }, 100);
                    }, 50);

                } catch (error) {
                    addStatusLog(`ä¸­æ–­ TTS æ’­æ”¾å¤±è´¥: ${error.message}`, 'error');
                }
            } else {
                // å½“å‰æ— TTSåœ¨æ’­ï¼Œä¹Ÿè¦å°è¯•æ¢å¤éº¦å…‹é£
                if (isMuted && audioStream) {
                    isMuted = false;
                    audioStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                    muteBtn.classList.remove('active');
                    muteBtn.textContent = 'ğŸ¤';
                    addStatusLog('æ¢å¤éº¦å…‹é£çŠ¶æ€', 'info');
                }
                interruptBtn.disabled = true;
                interruptBtn.classList.add('disabled');
                addMessage('å½“å‰æ²¡æœ‰æ­£åœ¨æ’­æ”¾çš„è¯­éŸ³', 'system');
            }
        }

        //================== 6. çŸ­æš‚åœé¡¿åˆå¹¶è¯†åˆ«é€»è¾‘ ==================//

        async function handleASRFinalResult(text) {
            // å…ˆå°†ç”¨æˆ·è¿™å¥è¯æ›´æ–°åˆ°ä¼šè¯è®°å¿†
            updateConversationMemory("user", text);

            addStatusLog(`è¯†åˆ«åˆ°æœ€ç»ˆæ–‡æœ¬: ${text}`, 'info');
            // ç´¯åŠ åˆ° pendingText
            pendingText = pendingText ? (pendingText + " " + text) : text;

            // å¦‚æœæœ‰è®¡æ—¶å™¨ï¼Œæ¸…é™¤å®ƒ
            if (finalTimer) {
                clearTimeout(finalTimer);
                finalTimer = null;
            }

            // ç­‰å¾… 1ç§’ åå†æ‰§è¡Œ
            finalTimer = setTimeout(async () => {
                // è®¤ä¸ºç”¨æˆ·è¯´è¯ç»“æŸ
                const userInput = pendingText.trim();
                addMessage(userInput, 'user'); // åœ¨ç•Œé¢ä¸Šæ˜¾ç¤º

                // è¯·æ±‚ AI
                const aiResponse = await getAIResponse(userInput);
                // æ’­æ”¾ TTS
                await playTTS(aiResponse.content);
                // æ˜¾ç¤º AI æ¶ˆæ¯
                addMessage(aiResponse.content, 'bot', aiResponse.resources);

                // æ¸…ç©º
                pendingText = "";
                finalTimer = null;
            }, WAIT_MS);
        }

        //================== 7. é€šè¯æ§åˆ¶ ==================//

        async function startCall() {
            try {
                addStatusLog('æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...', 'info');
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000
                    } 
                });
                addStatusLog('éº¦å…‹é£æƒé™è·å–æˆåŠŸ', 'success');

                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });

                // AudioWorklet
                const audioWorkletSource = document.getElementById('audioWorkletScript').textContent;
                const workletBlob = new Blob([audioWorkletSource], { type: 'text/javascript' });
                const workletUrl = URL.createObjectURL(workletBlob);
                await audioContext.audioWorklet.addModule(workletUrl);

                // WebSocket è¿æ¥
                const wsUrl = 'wss://192.168.8.167:10096'; // è¯·æ ¹æ®å®é™…ç¯å¢ƒä¿®æ”¹
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    addStatusLog('WebSocketè¿æ¥æˆåŠŸ', 'success');
                    const config = {
                        mode: "2pass",
                        chunk_size: [5, 10, 5],
                        chunk_interval: 10,
                        wav_name: "microphone",
                        is_speaking: true,
                        hotwords: "",
                        itn: true
                    };
                    ws.send(JSON.stringify(config));
                    addStatusLog('å·²å‘é€ASRé…ç½®ä¿¡æ¯', 'info');

                    // è¿æ¥ AudioWorklet
                    const source = audioContext.createMediaStreamSource(audioStream);
                    audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');
                    audioWorkletNode.port.onmessage = (event) => {
                        if (isCallActive && !isMuted && ws.readyState === WebSocket.OPEN) {
                            ws.send(event.data);
                        }
                    };
                    source.connect(audioWorkletNode);

                    addStatusLog('å¼€å§‹å½•éŸ³', 'success');
                };

                ws.onerror = (error) => {
                    addStatusLog(`WebSocketé”™è¯¯: ${error}`, 'error');
                };

                ws.onclose = () => {
                    addStatusLog('WebSocketè¿æ¥å·²å…³é—­', 'info');
                    endCall();
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        // å½“ ASR è¿”å› â€œ2pass-offlineâ€ è¡¨ç¤ºä¸€å¥è¯ç»“æŸ
                        if (data.text && data.mode === "2pass-offline") {
                            handleASRFinalResult(data.text);
                        }
                        // å¦‚æœæ˜¯ 2pass-online ç­‰å…¶ä»–æ¨¡å¼ï¼Œå¯è‡ªè¡Œå¤„ç†
                    } catch (err) {
                        addStatusLog(`å¤„ç†æ¶ˆæ¯é”™è¯¯: ${err.message}`, 'error');
                    }
                };

                isCallActive = true;
                callBtn.classList.add('active');
                callStatus.style.display = 'flex';
                addMessage('é€šè¯å·²å¼€å§‹ï¼Œæ‚¨å¯ä»¥å¼€å§‹å’¨è¯¢');
            } catch (error) {
                addStatusLog(`å¯åŠ¨é€šè¯é”™è¯¯: ${error.message}`, 'error');
                addMessage('å¯åŠ¨é€šè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™');
            }
        }

        async function endCall() {
            if (!isCallActive) return;
            addStatusLog('æ­£åœ¨ç»“æŸé€šè¯...', 'info');
            isCallActive = false;

            // å…³é—­ WebSocket
            if (ws) {
                ws.close();
                ws = null;
                addStatusLog('WebSocketå·²å…³é—­', 'info');
            }

            // æ–­å¼€éŸ³é¢‘å¤„ç†å™¨
            if (audioWorkletNode) {
                audioWorkletNode.disconnect();
                audioWorkletNode = null;
                addStatusLog('éŸ³é¢‘å¤„ç†å™¨å·²æ–­å¼€', 'info');
            }

            // å…³é—­å½•éŸ³ AudioContext
            if (audioContext) {
                try {
                    if (audioContext.state !== 'closed') {
                        await audioContext.close();
                        addStatusLog('æ•è·ç”¨AudioContextå·²å…³é—­', 'success');
                    }
                } catch (err) {
                    addStatusLog(`å…³é—­AudioContextå¤±è´¥: ${err.message}`, 'error');
                }
                audioContext = null;
            }

            // åœæ­¢éŸ³é¢‘æµ
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
                addStatusLog('éŸ³é¢‘æµå·²å…³é—­', 'info');
            }

            // å¦‚æœæœ‰å°šæœªåˆå¹¶çš„æ–‡æœ¬ï¼Œæ¸…ç©º
            if (pendingText) {
                pendingText = "";
            }
            if (finalTimer) {
                clearTimeout(finalTimer);
                finalTimer = null;
            }

            // å¦‚æœæœ‰ TTS æ­£åœ¨æ’­æ”¾ï¼Œåˆ™æ‰“æ–­
            if (currentTTSSource) {
                interruptTTS();
            }

            callBtn.classList.remove('active');
            callStatus.style.display = 'none';
            addMessage('é€šè¯å·²ç»“æŸ', 'system');
            addStatusLog('é€šè¯ç»“æŸå®Œæˆ', 'success');
        }

        //================== 8. æŒ‰é’®äº‹ä»¶ç»‘å®š ==================//

        callBtn.onclick = () => {
            if (!isCallActive) {
                startCall();
            } else {
                endCall();
            }
        };

        muteBtn.onclick = () => {
            if (audioStream) {
                isMuted = !isMuted;
                audioStream.getAudioTracks().forEach(track => {
                    track.enabled = !isMuted;
                });
                muteBtn.classList.toggle('active', isMuted);
                muteBtn.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ¤';
                addStatusLog(`éº¦å…‹é£å·²${isMuted ? 'é™éŸ³' : 'å–æ¶ˆé™éŸ³'}`, 'info');
            }
        };

        interruptBtn.onclick = () => {
            if (!interruptBtn.disabled) {
                interruptTTS();
            }
        };

        //================== 9. é¡µé¢åŠ è½½/å¸è½½å¤„ç† ==================//

        window.onload = () => {
            addStatusLog('é¡µé¢åˆå§‹åŒ–å¼€å§‹', 'info');

            // ç®€è¦æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ getUserMedia', 'error');
                return;
            }
            if (!window.WebSocket) {
                addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebSocket', 'error');
                return;
            }
            if (!window.AudioContext && !window.webkitAudioContext) {
                addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Audio API', 'error');
                return;
            }
            try {
                const tmpCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (!tmpCtx.audioWorklet) {
                    addStatusLog('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ AudioWorklet', 'error');
                    tmpCtx.close();
                    return;
                }
                tmpCtx.close();
            } catch (err) {
                addStatusLog(`AudioContext åˆå§‹åŒ–å¤±è´¥: ${err.message}`, 'error');
                return;
            }

            addStatusLog('æµè§ˆå™¨åŠŸèƒ½æ£€æŸ¥å®Œæˆ', 'success');
            addStatusLog('é¡µé¢åˆå§‹åŒ–å®Œæˆ', 'success');
            addMessage('ç³»ç»Ÿå°±ç»ªï¼Œç‚¹å‡»é€šè¯æŒ‰é’®å¼€å§‹å’¨è¯¢');
        };

        window.onbeforeunload = () => {
            if (isCallActive) {
                endCall();
            }
        };
    </script>
</body>
</html>
